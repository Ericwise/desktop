#include <node.h>
#include <uv.h>
#include <string>
#include <exception>

#include "nan.h"
#include "turtl.h"
#include "msg.h"

using namespace v8;

// our async handle, for messaging Node from C
uv_async_t async;

// tracks if we've initialized messaging already
int msg_has_init = 0;

// our message callback
NanCallback *msg_callback = (NanCallback*)NULL;

/**
 * Container class to pass our lisp string data to Node's main thread
 */
class lisp_data {
	public:
		unsigned long size;
		const unsigned char *data;

		lisp_data(unsigned long msg_length, const unsigned char *msg)
		{
			size = msg_length;
			data = new unsigned char[size];
			memcpy((void*)data, (void*)msg, size);
		}

		~lisp_data()
		{
			delete[] data;
		}
};

/**
 * The handler that gets all messages from lisp. Runs *in the lisp thread* and
 * must signal to Node that we have a message (via libuv's async functions).
 */
void TURTL_CONV main_message_handler(unsigned long msg_length, const unsigned char *msg)
{
	lisp_data *lispstr  = new lisp_data(msg_length, msg);
	async.data = (void*)lispstr;
	uv_async_send(&async);
}

/**
 * Takes the value sent from main_message_handler and shoves it into our Node
 * callback.
 */
void msg_node(uv_async_t *handle, int status)
{
	NanScope();

	if(msg_callback == (NanCallback*)NULL)
	{
		// if we don't have a callback, then do nothing
		return;
	}

	lisp_data *lispstr = (lisp_data*)handle->data;

	TryCatch try_catch;

	// call our message callback
	Local<Value> argv[] = { String::New((const char*)lispstr->data, lispstr->size) };
	msg_callback->Call(1, argv);

	// free our lisp_data object
	delete lispstr;

	if(try_catch.HasCaught())
	{
		printf("node: callback: got exception: %s\n", "unknown");
	}
}

/**
 * Initialize the messaging system.
 */
void init_messaging()
{
	if(msg_has_init == 1)
	{
		return;
	}
	uv_async_init(uv_default_loop(), &async, msg_node);
	turtl_set_ui_msg_handler(&main_message_handler);
	msg_has_init = 1;
}

/**
 * Give our C interface a callback that takes a message which can be passed,
 * async, into Node.js
 */
NAN_METHOD(set_msg_callback) {
	NanScope();

	if(msg_callback != (NanCallback*)NULL)
	{
		delete msg_callback;
	}
	Local<Function> cb_handle = args[0].As<Function>();
	msg_callback = new NanCallback(cb_handle);

	NanReturnUndefined();
}

/**
 * Send a message to lisp.
 */
NAN_METHOD(send_msg_lisp) {
	NanScope();
	String::Utf8Value msg(args[0]->ToString());
	std::string uistr = std::string(*msg);

	turtl_msg_to_lisp((unsigned long)uistr.length(), (const unsigned char *)uistr.c_str());

	NanReturnUndefined();
}

